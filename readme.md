## <Programing in go>

### 目录
第一章 [五个例子](#第一章-五个例子)

第二章 [布尔与数值](#第二章-布尔与数值)

第三章 [字符串](#第三章-字符串)

第四章 [集合类型](#第四章-集合类型)

第五章 [过程式编程](#第五章-过程式编程)

第六章 [面向对象编程](#第六章-面向对象编程)

第七章 [并发编程](#第七章-并发编程)

第八章 [文件处理](#第八章-文件处理)

第九章 [包](#第九章-包)


-------------------

## 第一章 五个例子
**1.5 栈和自定义方法**

- 自定义集合类型都应该实现 `Len()` 和 `Cap()` 方法
- `*` 在不同位置含义不同
	- 在 `类型名称` 前 表示指针 *int
	- 在 两个数字或者变量之间表示乘法 x*y
	- 在 `变量名称` 前 表示解引用, 也就是引用该指针所指向的值 *stack
- 不建议使用不带返回值的return语句

-----------------------------------

## 第二章 布尔与数值

**2.1 基础**

- 常量
  ```go
  const limit = 512 //类型兼容任何数字,例如可以直接和time.Duration类型相乘 time.Second * limit 
  const top uint16 = 1421 // 类型 uint16 

  ```



-------------------

## 第三章 字符串


------------------------------------------------------

## 第四章 集合类型


------------------------------------------------------

## 第五章 过程式编程


------------------------------------------------------

## 第六章 面向对象编程


------------------------------------------------------

## 第七章 并发编程


**7.1 如何创建一个管道最大化吞吐量,管道每一部分都各自独立执行一个goroutine**
- 通道的数据安全
	- 在通道中传输 bool int float类型都是安全的，因为采用的复制的方式传送，字符串不能修改所有也是安全的
	- 当通道里发送指针或引用类型，通常是不安全的，有三种方法可以保证安全
		- 互斥串行化访问，应该保证只能被一个goroutine访问得到，除非指针所指向的值的所有方法都不会改变它
		- 指定规则，发送方发送后就不再访问，完全让接受方访问、释放或者引用指向的值
		- 所有公开的方法(可导出的方法)都不能修改值，所有可以修改值的方法都不导出。这样可以外部并发访问，内部只实现一个goroutine访问非导出方法

**7.2 如何将一个工作切分成固定的若干个goroutine去完成并每部分输出结果独立**
- 带有通道参数的函数 通常目标通道放在前面,源通道在后
- 一个只读通道不能被关闭

**7.3 如何不使用锁和底层原语创建一个线程安全的数据结构**
- 安全映射的实现其实就是在一个goroutine内执行一个内部方法以操作普通的map数据结构。外界只能通过通道来操作这个内部映射，这样能保证对映射的所有访问是串行的
- 
**7.4 三种方法使用固定若干个goroutine独立处理工作并将结果汇总**
**7.5 动态创建goroutine并将结果输出的一个结果集中**


------------------------------------------------------

## 第八章 文件处理


------------------------------------------------------
## 第九章 包


-----------------------------------